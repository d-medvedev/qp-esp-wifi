/*$file${../main::bip-cloud.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: wifi.qm
* File:  ${../main::bip-cloud.c}
*
* This code has been generated by QM 5.2.4 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${../main::bip-cloud.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"

#include "bip_cloud.h"

static const char *TAG = "MQTT";

static esp_mqtt_client_handle_t client = NULL;
static topic_subscribe_set_t* ptr_bd_topics_subscribe = NULL;

static esp_mqtt_client_config_t mqtt_cfg = {

    #if defined(MQTT_URI)
        .uri = MQTT_URI,
    #elif defined(MQTT_HOST)
        .host = MQTT_HOST,
    #endif

    #if defined(MQTT_PORT)
        .port = 1883,
    #endif

    #if (defined(MQTT_USERNAME) && defined(MQTT_PASSWORD))
        .password = MQTT_PASSWORD,
        .username = MQTT_USERNAME,
    #endif

    .disable_auto_reconnect = false,
    .keepalive = 10,
};

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 700U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 7.0.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${AOs::Cloud} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${AOs::Cloud} ............................................................*/
Cloud Cloud_obj;

/*${AOs::Cloud::SM} ........................................................*/
QState Cloud_initial(Cloud * const me, void const * const par) {
    /*${AOs::Cloud::SM::initial} */
    // Subscribt to required signals from QF
    QActive_subscribe(&me->super, GOT_IP_SIG);
    QActive_subscribe(&me->super, DISCONNECT_SIG);
    QActive_subscribe(&me->super, MQTT_CONNECTED_SIG);
    mqtt_app_init(list_topics_subscribe);
    return Q_TRAN(&Cloud_active);
}

/*${AOs::Cloud::SM::active} ................................................*/
QState Cloud_active(Cloud * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Cloud::SM::active::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Cloud_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/*${AOs::Cloud::SM::active::connected} .....................................*/
QState Cloud_connected(Cloud * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Cloud::SM::active::connected} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "MQTT Connected state");

            QTimeEvt_armX(&me->sendTimeEvt, BSP_TICKS_PER_SEC/2U,
                          BSP_TICKS_PER_SEC/2U);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Cloud::SM::active::connected} */
        case Q_EXIT_SIG: {
            ESP_ERROR_CHECK(mqtt_stop());
            CloudEvt *pe = Q_NEW(CloudEvt, MQTT_DISCONNECTED_SIG);
            QACTIVE_PUBLISH(&pe->super, AO_Cloud);
            QTimeEvt_disarm(&me->sendTimeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Cloud::SM::active::connected::DISCONNECT} */
        case DISCONNECT_SIG: {
            status_ = Q_TRAN(&Cloud_idle);
            break;
        }
        /*${AOs::Cloud::SM::active::connected::SEND_TIMEOUT} */
        case SEND_TIMEOUT_SIG: {
            ESP_LOGI(TAG, "Send timer expired");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Cloud_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Cloud::SM::active::idle} ..........................................*/
QState Cloud_idle(Cloud * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Cloud::SM::active::idle} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "MQTT IDLE state");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Cloud::SM::active::idle::GOT_IP} */
        case GOT_IP_SIG: {
            status_ = Q_TRAN(&Cloud_try_connect);
            break;
        }
        default: {
            status_ = Q_SUPER(&Cloud_active);
            break;
        }
    }
    return status_;
}

/*${AOs::Cloud::SM::active::try_connect} ...................................*/
QState Cloud_try_connect(Cloud * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${AOs::Cloud::SM::active::try_connect} */
        case Q_ENTRY_SIG: {
            ESP_ERROR_CHECK(mqtt_start());
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Cloud::SM::active::try_connect::MQTT_CONNECTED} */
        case MQTT_CONNECTED_SIG: {
            status_ = Q_TRAN(&Cloud_connected);
            break;
        }
        default: {
            status_ = Q_SUPER(&Cloud_active);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Cloud} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${Shared::Cloud_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Shared::Cloud_ctor} ....................................................*/
void Cloud_ctor(void) {
    Cloud *me = &Cloud_obj;

    QActive_ctor(&Cloud_obj.super, Q_STATE_CAST(&Cloud_initial));
    QTimeEvt_ctorX(&me->sendTimeEvt, &me->super, SEND_TIMEOUT_SIG, 0U);
}
/*$enddef${Shared::Cloud_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${Shared::AO_Cloud} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${Shared::AO_Cloud} ......................................................*/
QActive * const AO_Cloud  = &Cloud_obj.super;
/*$enddef${Shared::AO_Cloud} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) {
    ESP_LOGD(TAG, "Event dispatched from event loop base=%s, event_id=%d", base, event_id);
    esp_mqtt_event_handle_t event = event_data;
    client = event->client;
    int msg_id;
    switch ((esp_mqtt_event_id_t)event_id) {
    case MQTT_EVENT_CONNECTED: {
        ESP_LOGI(TAG, "MQTT_EVENT_CONNECTED");
        CloudEvt *pe = Q_NEW(CloudEvt, MQTT_CONNECTED_SIG);
        QACTIVE_PUBLISH(&pe->super, AO_Cloud);
        // mqtt_is_connect = true;
        // send_event_net(EVENT_MQTT_CONNECT_COMPLETED);
        // uint8_t idx_topic = 0;
        // while(*(uint32_t*)(&ptr_bd_topics_subscribe[idx_topic]) != '\0') {
        //     if (ptr_bd_topics_subscribe[idx_topic].topic && ptr_bd_topics_subscribe[idx_topic].topic[0] != '\0') {
        //         msg_id = esp_mqtt_client_subscribe(client, ptr_bd_topics_subscribe[idx_topic].topic, ptr_bd_topics_subscribe[idx_topic].qos);
        //         ESP_LOGI(TAG, "Subscribe successful, topic = \"%s\" msg_id=%d",ptr_bd_topics_subscribe[idx_topic].topic, msg_id);
        //     }
        //     idx_topic++;
        // }
        break;
    }

    case MQTT_EVENT_DISCONNECTED:
        ESP_LOGI(TAG, "MQTT_EVENT_DISCONNECTED");
        // mqtt_is_connect = false;
        // send_event_net(EVENT_MQTT_CONNECT_FAIL);
        break;

    case MQTT_EVENT_SUBSCRIBED:
        ESP_LOGI(TAG, "MQTT_EVENT_SUBSCRIBED, msg_id=%d", event->msg_id);
        break;
    case MQTT_EVENT_UNSUBSCRIBED:
        ESP_LOGI(TAG, "MQTT_EVENT_UNSUBSCRIBED, msg_id=%d", event->msg_id);
        break;
    case MQTT_EVENT_PUBLISHED:
        ESP_LOGI(TAG, "MQTT_EVENT_PUBLISHED, msg_id=%d", event->msg_id);
        break;
    case MQTT_EVENT_DATA: {
        ESP_LOGI(TAG, "MQTT_EVENT_DATA");
        // uint8_t idx_topic = 0;
        // while(*(uint32_t*)(&ptr_bd_topics_subscribe[idx_topic]) != '\0') {
        //     if (!strncmp(event->topic, ptr_bd_topics_subscribe->topic, event->data_len)) {

        //         if (ptr_bd_topics_subscribe->hanler_provide) {
        //             ptr_bd_topics_subscribe->hanler_provide(event->data, event->data_len);
        //         }
        //     }
        //     idx_topic++;
        // }
        break;
    }

    case MQTT_EVENT_ERROR:
        ESP_LOGI(TAG, "MQTT_EVENT_ERROR");
        // if (event->error_handle->error_type == MQTT_ERROR_TYPE_TCP_TRANSPORT) {
        //     log_error_if_nonzero("reported from esp-tls", event->error_handle->esp_tls_last_esp_err);
        //     log_error_if_nonzero("reported from tls stack", event->error_handle->esp_tls_stack_err);
        //     log_error_if_nonzero("captured as transport's socket errno",  event->error_handle->esp_transport_sock_errno);
        //     ESP_LOGI(TAG, "Last errno string (%s)", strerror(event->error_handle->esp_transport_sock_errno));
        //     mqtt_reconnect();
        // }
        break;
    case MQTT_EVENT_BEFORE_CONNECT: {

    }
    break;
    default:
        ESP_LOGI(TAG, "Other event id:%d", event->event_id);
        break;
    }
}

esp_err_t mqtt_start(void) {
    return esp_mqtt_client_start(client);
}

esp_err_t mqtt_stop(void) {
    return esp_mqtt_client_stop(client);
}

esp_err_t mqtt_reconnect(void) {
    return esp_mqtt_client_reconnect(client);
}

esp_err_t mqtt_disconnect(void) {
    return esp_mqtt_client_disconnect(client);
}

int mqtt_publish(const char *topic, const char *data, int len, int qos, int retain) {
    if (esp_mqtt_client_publish(client, topic, data, len, qos, retain) > 0) {
        return ESP_OK;
    }
    return ESP_FAIL;
}

esp_err_t mqtt_app_init(topic_subscribe_set_t* bd_topics_subscribe) {
    ptr_bd_topics_subscribe = bd_topics_subscribe;
    client = esp_mqtt_client_init(&mqtt_cfg);
    return esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, NULL);
}
