/*$file${../main::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: wifi.qm
* File:  ${../main::bsp.c}
*
* This code has been generated by QM 5.2.4 <www.state-machine.com/qm>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* SPDX-License-Identifier: GPL-3.0-or-later
*
* This generated code is open source software: you can redistribute it under
* the terms of the GNU General Public License as published by the Free
* Software Foundation.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* NOTE:
* Alternatively, this generated code may be distributed under the terms
* of Quantum Leaps commercial licenses, which expressly supersede the GNU
* General Public License and are specifically designed for licensees
* interested in retaining the proprietary status of their code.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${../main::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

#include "qpc.h"
#include "qf_port.h"

#include <string.h>

#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/FreeRTOS.h"
#include "esp_log.h"
#include "esp_freertos_hooks.h"
#include "driver/gpio.h"

#include "bmp280.h"

#include "bsp.h"
#include "wifi_button.h"


static const char * TAG = "bsp";

static bmp280_t bmp280_obj;
static bmp280_params_t bmp280_params;

static float temperature, pressure, humidity;

int_t qf_run_active = 0;

bool debounce_switch(uint8_t buttonType)
{
    static uint16_t button_state = 0; // Current debounce status

    button_state = (button_state << 1) | !gpio_get_level(buttonType) | 0xe000;

    if (button_state == 0xf000) return true;
    return false;
}

static void buttons_processing_task(void* arg)
{
    printf("Button task started \n");
    static uint32_t bmp_read_cntr;

    for(;;) {        

        if (debounce_switch((uint8_t)BUTTON_A)) {

            ButtonEvt *pe = Q_NEW(ButtonEvt, BUTTON_PRESSED_SIG);
            pe->buttonNum = BUTTON_A;
            QACTIVE_PUBLISH(&pe->super, AO_Button);
            printf("Button A pressed \n");
        }
        else if (debounce_switch((uint8_t)BUTTON_B))
        {
            ButtonEvt *pe = Q_NEW(ButtonEvt, BUTTON_PRESSED_SIG);
            pe->buttonNum = BUTTON_B;
            QACTIVE_PUBLISH(&pe->super, AO_Button);
            printf("Button B pressed \n");
        }
        else if (debounce_switch((uint8_t)BUTTON_C)) {
            ButtonEvt *pe = Q_NEW(ButtonEvt, BUTTON_PRESSED_SIG);
            pe->buttonNum = BUTTON_C;
            QACTIVE_PUBLISH(&pe->super, AO_Button);
            printf("Button C pressed \n");
        }
        
        // if (++bmp_read_cntr % 20 == 0)
        // {
        //     #if 1
        //         bmp280_read_float(&bmp280_obj, &temperature, &pressure, &humidity);
        //         printf("Temp: %.2f Pressure: %.2f \n", temperature, pressure);
        //     #endif
        // }

        vTaskDelay(50 / portTICK_RATE_MS);
    }
}

static IRAM_ATTR void freertos_tick_hook(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    if(qf_run_active != 0) {
        /* process time events for rate 0 */
        QTIMEEVT_TICK_FROM_ISR(0U, &xHigherPriorityTaskWoken, &freertos_tick_hook);
        /* notify FreeRTOS to perform context switch from ISR, if needed */
        if(xHigherPriorityTaskWoken) {
            portYIELD_FROM_ISR();
        }
    }
}

void QF_onStartup(void)
{
    esp_register_freertos_tick_hook_for_cpu(freertos_tick_hook, QPC_CPU_NUM);

    /* enable QF ticks from tick hook */
    qf_run_active = 100;

    ESP_LOGI(TAG, "QF started.");

    /* Note: Additional hook stuff can be placed here */
}

IRAM_ATTR void Q_onAssert(char_t const * const module, int_t location)
{
    ESP_LOGE(TAG, "Q_onAssert: module:%s loc:%d\n", module, location);
}

bool read_bmp280_data(float *t, float *p)
{
    if (bmp280_read_float(&bmp280_obj, t, p, &humidity))
    {
        return true;
    }
    return false;
}

void bsp_init (void) {

    //Zero-initialize the config structure.
    gpio_config_t io_conf = {};

    //Bit mask of the pins, use GPIO39 here
    io_conf.pin_bit_mask = GPIO_INPUT_PIN_SEL;
    
    //Set as input mode
    io_conf.mode = GPIO_MODE_INPUT;
    
    //Enable pull-up mode
    io_conf.pull_up_en = 1;

    gpio_config(&io_conf);

    // Configure I2C interface and BMP280 sensor
    ESP_ERROR_CHECK(i2cdev_init());
    bmp280_init_default_params(&bmp280_params);
    memset(&bmp280_obj, 0, sizeof(bmp280_t));
    bmp280_init_desc(&bmp280_obj, BMP280_I2C_ADDRESS_0, I2C_NUM_0, GPIO_NUM_21, GPIO_NUM_22);
    bmp280_init(&bmp280_obj, &bmp280_params);

    //Start gpio task
    xTaskCreate(buttons_processing_task, "buttons_processing_task", 2048, NULL, 10, NULL);
    
    vTaskDelay(1000 / portTICK_RATE_MS);

    ESP_LOGI(TAG, "GPIO configuration done");
}
