<?xml version="1.0" encoding="UTF-8"?>
<model version="5.2.4" links="0">
 <framework name="qpc"/>
 <package name="AOs" stereotype="0x02">
  <class name="Button" superclass="qpc::QActive">
   <attribute name="obj" type="Button" visibility="0x00" properties="0x01"/>
   <attribute name="timeEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <attribute name="press_cntr" type="uint32_t" visibility="0x02" properties="0x00"/>
   <statechart properties="0x00">
    <initial target="../1">
     <action>ESP_LOGI(TAG, &quot;Button Initial transition&quot;);
QActive_subscribe(&amp;me-&gt;super, BUTTON_PRESSED_SIG);</action>
     <initial_glyph conn="26,6,5,0,6,7">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Button">
     <tran trig="BUTTON_PRESSED">
      <action>switch (Q_EVT_CAST(ButtonEvt)-&gt;buttonNum) {
    case BUTTON_A: {
        ButtonEvt *pe = Q_NEW(ButtonEvt, CONNECT_SIG);
        QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_Button);
        break;
    }

    case BUTTON_B: {
        ButtonEvt *pe = Q_NEW(ButtonEvt, DISCONNECT_SIG);
        QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_Button);
        break;
    }

    case BUTTON_C: {
        me-&gt;press_cntr++;
        if (me-&gt;press_cntr % 2)
        {
            ButtonEvt *pe = Q_NEW(ButtonEvt, STOP_TELEMETRY_SIG);
            QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_Button);
        }
        else
        {
            ButtonEvt *pe = Q_NEW(ButtonEvt, START_TELEMETRY_SIG);
            QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_Button);
        }
        break;
    }

    default:
    break;
}</action>
      <tran_glyph conn="8,19,3,-1,20">
       <action box="1,-3,18,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="8,13,47,16"/>
    </state>
    <state_diagram size="94,60"/>
   </statechart>
  </class>
  <class name="WiFi" superclass="qpc::QActive">
   <attribute name="obj" type="WiFi" visibility="0x00" properties="0x01"/>
   <statechart properties="0x00">
    <initial target="../2">
     <initial_glyph conn="20,22,4,3,3,7">
      <action box="0,-2,8,2"/>
     </initial_glyph>
    </initial>
    <state name="sta_started">
     <tran trig="MQTT_DISCONNECTED" target="../3">
      <tran_glyph conn="20,77,3,3,45">
       <action box="0,-2,20,3"/>
      </tran_glyph>
     </tran>
     <tran trig="CONNECT" target="../4">
      <tran_glyph conn="20,47,3,3,44">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="connected">
      <tran trig="GOT_IP" target="../../5">
       <tran_glyph conn="64,66,3,1,-24">
        <action box="-16,-2,11,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="64,58,14,11"/>
     </state>
     <state name="disconnect">
      <entry>esp_wifi_disconnect();</entry>
      <state_glyph node="65,74,14,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="try_connect">
      <entry>ESP_LOGI(TAG, &quot;Connecting state&quot;);

esp_wifi_connect();</entry>
      <tran trig="CONNECTED" target="../../2">
       <tran_glyph conn="71,54,2,0,4">
        <action box="-11,1,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="64,43,14,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="got_ip">
      <tran trig="LOST_IP" target="../../2">
       <tran_glyph conn="40,61,1,3,24">
        <action box="8,-2,9,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="26,58,14,11"/>
     </state>
     <state_glyph node="20,38,61,50"/>
    </state>
    <state name="init">
     <entry>// Subscribt to required signals from QF
QActive_subscribe(&amp;me-&gt;super, CONNECT_SIG);
QActive_subscribe(&amp;me-&gt;super, CONNECTED_SIG);
QActive_subscribe(&amp;me-&gt;super, GOT_IP_SIG);
QActive_subscribe(&amp;me-&gt;super, LOST_IP_SIG);
QActive_subscribe(&amp;me-&gt;super, STA_STARTED_SIG);
QActive_subscribe(&amp;me-&gt;super, CONNECTION_LOST_SIG);
QActive_subscribe(&amp;me-&gt;super, MQTT_DISCONNECTED_SIG);

// Disable default WiFi logging messages
esp_log_level_set(&quot;wifi&quot;, ESP_LOG_NONE);

s_wifi_event_group = xEventGroupCreate();

// Event loop for the WiFi driver
ESP_ERROR_CHECK(esp_event_loop_create_default());

// Create event hadler for the connection
esp_event_handler_instance_t instance_wifi_event;
esp_event_handler_instance_t instance_ip_event;
ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;event_handler, NULL, &amp;instance_wifi_event));
ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, ESP_EVENT_ANY_ID, &amp;event_handler, NULL, &amp;instance_ip_event));

// Initialize the TCP stack
ESP_ERROR_CHECK(esp_netif_init());

// Default WiFi config - operations must be in this order
wifi_init_config_t wifi_config = WIFI_INIT_CONFIG_DEFAULT();
ESP_ERROR_CHECK(esp_wifi_init(&amp;wifi_config));
ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_RAM));

esp_netif_sta = esp_netif_create_default_wifi_sta();

// Start WiFi
ESP_ERROR_CHECK(esp_wifi_start());</entry>
     <tran trig="STA_STARTED" target="../../1">
      <tran_glyph conn="34,30,2,0,8">
       <action box="1,2,12,3"/>
      </tran_glyph>
     </tran>
     <state_glyph node="27,19,14,11">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="105,197"/>
   </statechart>
  </class>
  <class name="Cloud" superclass="qpc::QActive">
   <attribute name="obj" type="Cloud" visibility="0x00" properties="0x01"/>
   <attribute name="sendTimeEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <statechart properties="0x00">
    <initial target="../1">
     <action>// Subscribt to required signals from QF
QActive_subscribe(&amp;me-&gt;super, GOT_IP_SIG);
QActive_subscribe(&amp;me-&gt;super, DISCONNECT_SIG);
QActive_subscribe(&amp;me-&gt;super, MQTT_CONNECTED_SIG);
mqtt_app_init(list_topics_subscribe);</action>
     <initial_glyph conn="5,4,5,0,11,5">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="active">
     <initial target="../2">
      <initial_glyph conn="72,14,5,1,-6,7,-2">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <state name="connected">
      <entry>ESP_LOGI(TAG, &quot;MQTT Connected state&quot;);

QTimeEvt_armX(&amp;me-&gt;sendTimeEvt, BSP_TICKS_PER_SEC/2U,
              BSP_TICKS_PER_SEC/2U);</entry>
      <exit>ESP_ERROR_CHECK(mqtt_stop());
CloudEvt *pe = Q_NEW(CloudEvt, MQTT_DISCONNECTED_SIG);
QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_Cloud);
QTimeEvt_disarm(&amp;me-&gt;sendTimeEvt);</exit>
      <tran trig="DISCONNECT" target="../../2">
       <tran_glyph conn="29,37,1,2,26,-12">
        <action box="1,-2,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="SEND_TIMEOUT">
       <action>ESP_LOGI(TAG, &quot;Send timer expired&quot;);</action>
       <tran_glyph conn="12,38,3,-1,6">
        <action box="0,-2,12,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="12,32,17,9">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="idle">
      <entry>ESP_LOGI(TAG, &quot;MQTT IDLE state&quot;);</entry>
      <tran trig="GOT_IP" target="../../3">
       <tran_glyph conn="47,21,3,1,-19">
        <action box="-12,-3,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="47,17,17,8">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="try_connect">
      <entry>ESP_ERROR_CHECK(mqtt_start());</entry>
      <tran trig="MQTT_CONNECTED" target="../../1">
       <tran_glyph conn="20,25,2,0,7">
        <action box="1,2,17,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="12,17,16,8">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="8,9,68,35"/>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
 </package>
 <package name="Shared" stereotype="0x01">
  <class name="WifiEvt" superclass="qpc::QEvt">
   <attribute name="n" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="ButtonEvt" superclass="qpc::QEvt">
   <attribute name="buttonNum" type="uint8_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="CloudEvt" superclass="qpc::QEvt"/>
  <operation name="WiFi_ctor" type="void" visibility="0x00" properties="0x00">
   <code>QActive_ctor(&amp;WiFi_obj.super, Q_STATE_CAST(&amp;WiFi_initial));</code>
  </operation>
  <operation name="Cloud_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Cloud *me = &amp;Cloud_obj;

QActive_ctor(&amp;Cloud_obj.super, Q_STATE_CAST(&amp;Cloud_initial));
QTimeEvt_ctorX(&amp;me-&gt;sendTimeEvt, &amp;me-&gt;super, SEND_TIMEOUT_SIG, 0U);</code>
  </operation>
  <operation name="Button_ctor" type="void" visibility="0x00" properties="0x00">
   <code>Button *me = &amp;Button_obj;

QActive_ctor(&amp;Button_obj.super, Q_STATE_CAST(&amp;Button_initial));
me-&gt;press_cntr = 0;</code>
  </operation>
  <attribute name="AO_Button" type="QActive * const" visibility="0x00" properties="0x00">
   <code> = &amp;Button_obj.super;</code>
  </attribute>
  <attribute name="AO_WiFi" type="QActive * const" visibility="0x00" properties="0x00">
   <code> = &amp;WiFi_obj.super;</code>
  </attribute>
  <attribute name="AO_Cloud" type="QActive * const" visibility="0x00" properties="0x00">
   <code> = &amp;Cloud_obj.super;</code>
  </attribute>
 </package>
 <directory name="../main">
  <file name="qhsm-wifi.c">
   <text>#include &quot;qpc.h&quot;

#include &quot;freertos/FreeRTOS.h&quot;
#include &quot;freertos/task.h&quot;
#include &quot;freertos/event_groups.h&quot;
#include &quot;esp_system.h&quot;
#include &quot;esp_wifi.h&quot;
#include &quot;esp_event.h&quot;
#include &quot;esp_log.h&quot;

#include &quot;lwip/err.h&quot;
#include &quot;lwip/sys.h&quot;

#include &quot;wifi_button.h&quot;
#include &quot;config_sta.h&quot;

static const char * TAG = &quot;qhsm_wifi&quot;;

static EventGroupHandle_t s_wifi_event_group;
static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);

// netif objects for the station and access point
esp_netif_t* esp_netif_sta = NULL;

static wifi_config_t wifi_config = {
    .sta = {
        .ssid = WIFI_SSID,
        .password = WIFI_PASSWORD,

        .threshold.authmode = WIFI_AUTH_WPA2_PSK,

        .pmf_cfg = {
            .capable = true,
            .required = false
        },
    },
};

$define${AOs::WiFi}
$define${Shared::WiFi_ctor}
$define${Shared::AO_WiFi}

static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) {
    if (event_base == WIFI_EVENT) {
        switch(event_id) {

            case WIFI_EVENT_STA_START: {
                WifiEvt *pe = Q_NEW(WifiEvt, STA_STARTED_SIG);
                QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_WiFi);
                ESP_LOGW(TAG, &quot;WIFI_EVENT_STA_START&quot;);
            }
            break;

            case WIFI_EVENT_STA_DISCONNECTED: {
                system_event_sta_disconnected_t* event = (system_event_sta_disconnected_t*)event_data;
                ESP_LOGW(TAG,&quot;WIFI_EVENT_STA_DISONNECTED&quot;);
                WifiEvt *pe = Q_NEW(WifiEvt, DISCONNECTED_SIG);
                QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_WiFi);
            }
            break;

            case WIFI_EVENT_STA_CONNECTED: {
                WifiEvt *pe = Q_NEW(WifiEvt, CONNECTED_SIG);
                QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_WiFi);
                ESP_LOGW(TAG, &quot;WIFI_EVENT_STA_CONNECTED&quot;);
            }
            break;
        }
    } else if (event_base == IP_EVENT) {
        switch(event_id) {
            case IP_EVENT_STA_GOT_IP: {
                WifiEvt *pe = Q_NEW(WifiEvt, GOT_IP_SIG);
                QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_WiFi);
                ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
                ESP_LOGI(TAG, &quot;got ip:&quot; IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));
                ESP_LOGW(TAG, &quot;IP_EVENT_STA_GOT_IP&quot;);
            }
            break;
        }
    }
}
</text>
  </file>
  <file name="qhsm-button.c">
   <text>#include &quot;qpc.h&quot;

#include &quot;esp_system.h&quot;
#include &quot;esp_wifi.h&quot;
#include &quot;esp_event.h&quot;
#include &quot;esp_log.h&quot;

#include &quot;bsp.h&quot;
#include &quot;wifi_button.h&quot;

static const char * TAG = &quot;button&quot;;

$define${AOs::Button}
$define${Shared::Button_ctor}
$define${Shared::AO_Button}</text>
  </file>
  <file name="wifi_button.h">
   <text>#ifndef WF_BUTTON_H
#define WF_BUTTON_H

#define DEBOUNCE_TIME 3

enum wifiSignals {
    DISCONNECTED_SIG = Q_USER_SIG,
    STA_STARTED_SIG,
    CONNECT_SIG,
    CONNECTED_SIG,
    CONNECTION_LOST_SIG,
    GOT_IP_SIG,
    LOST_IP_SIG,
    BUTTON_PRESSED_SIG,
    START_TELEMETRY_SIG,
    STOP_TELEMETRY_SIG,
    SEND_TIMEOUT_SIG,
    DISCONNECT_SIG,
    MQTT_CONNECTED_SIG,
    MQTT_DISCONNECTED_SIG,

    MAX_PUB_SIG
};

$declare${AOs::Button}
$declare${AOs::WiFi}
$declare${AOs::Cloud}

$declare${Shared::ButtonEvt}
$declare${Shared::WifiEvt}
$declare${Shared::CloudEvt}

$declare${Shared::AO_WiFi}
$declare${Shared::AO_Button}
$declare${Shared::AO_Cloud}

$declare${Shared::WiFi_ctor}
$declare${Shared::Button_ctor}
$declare${Shared::Cloud_ctor}

#endif</text>
  </file>
  <file name="mqtt_settings.h">
   <text>#ifndef MQTT_SETTINGS_H
#define MQTT_SETTINGS_H

#define     IN_TOPIC        &quot;devices/in/bip-esp-32/94B97EC34E10&quot;
#define     OUT_TOPIC       &quot;devices/out/bip-esp-32/94B97EC34E10&quot;
#define     MQTT_URI        &quot;mqtt://emqx.bip.app-server.net/&quot;
#define     MQTT_PORT        (1883)

#define     MQTT_USERNAME       &quot;iot_device&quot;
#define     MQTT_PASSWORD       &quot;qwerty&quot;

#endif //MQTT_SETTINGS_H</text>
  </file>
  <file name="bip-cloud.c">
   <text>#include &quot;qpc.h&quot;

#include &quot;bip_cloud.h&quot;

static const char *TAG = &quot;MQTT&quot;;

static esp_mqtt_client_handle_t client = NULL;
static topic_subscribe_set_t* ptr_bd_topics_subscribe = NULL;

static esp_mqtt_client_config_t mqtt_cfg = {

    #if defined(MQTT_URI)
        .uri = MQTT_URI,
    #elif defined(MQTT_HOST)
        .host = MQTT_HOST,
    #endif

    #if defined(MQTT_PORT)
        .port = 1883,
    #endif

    #if (defined(MQTT_USERNAME) &amp;&amp; defined(MQTT_PASSWORD))
        .password = MQTT_PASSWORD,
        .username = MQTT_USERNAME,
    #endif

    .disable_auto_reconnect = false,
    .keepalive = 10,
};

$define${AOs::Cloud}
$define${Shared::Cloud_ctor}
$define${Shared::AO_Cloud}

static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) {
    ESP_LOGD(TAG, &quot;Event dispatched from event loop base=%s, event_id=%d&quot;, base, event_id);
    esp_mqtt_event_handle_t event = event_data;
    client = event-&gt;client;
    int msg_id;
    switch ((esp_mqtt_event_id_t)event_id) {
    case MQTT_EVENT_CONNECTED: {
        ESP_LOGI(TAG, &quot;MQTT_EVENT_CONNECTED&quot;);
        CloudEvt *pe = Q_NEW(CloudEvt, MQTT_CONNECTED_SIG);
        QACTIVE_PUBLISH(&amp;pe-&gt;super, AO_Cloud);
        // mqtt_is_connect = true;
        // send_event_net(EVENT_MQTT_CONNECT_COMPLETED);
        // uint8_t idx_topic = 0;
        // while(*(uint32_t*)(&amp;ptr_bd_topics_subscribe[idx_topic]) != '\0') {
        //     if (ptr_bd_topics_subscribe[idx_topic].topic &amp;&amp; ptr_bd_topics_subscribe[idx_topic].topic[0] != '\0') {
        //         msg_id = esp_mqtt_client_subscribe(client, ptr_bd_topics_subscribe[idx_topic].topic, ptr_bd_topics_subscribe[idx_topic].qos);
        //         ESP_LOGI(TAG, &quot;Subscribe successful, topic = \&quot;%s\&quot; msg_id=%d&quot;,ptr_bd_topics_subscribe[idx_topic].topic, msg_id);
        //     }
        //     idx_topic++;
        // }
        break;
    }

    case MQTT_EVENT_DISCONNECTED:
        ESP_LOGI(TAG, &quot;MQTT_EVENT_DISCONNECTED&quot;);
        // mqtt_is_connect = false;
        // send_event_net(EVENT_MQTT_CONNECT_FAIL);
        break;

    case MQTT_EVENT_SUBSCRIBED:
        ESP_LOGI(TAG, &quot;MQTT_EVENT_SUBSCRIBED, msg_id=%d&quot;, event-&gt;msg_id);
        break;
    case MQTT_EVENT_UNSUBSCRIBED:
        ESP_LOGI(TAG, &quot;MQTT_EVENT_UNSUBSCRIBED, msg_id=%d&quot;, event-&gt;msg_id);
        break;
    case MQTT_EVENT_PUBLISHED:
        ESP_LOGI(TAG, &quot;MQTT_EVENT_PUBLISHED, msg_id=%d&quot;, event-&gt;msg_id);
        break;
    case MQTT_EVENT_DATA: {
        ESP_LOGI(TAG, &quot;MQTT_EVENT_DATA&quot;);
        // uint8_t idx_topic = 0;
        // while(*(uint32_t*)(&amp;ptr_bd_topics_subscribe[idx_topic]) != '\0') {
        //     if (!strncmp(event-&gt;topic, ptr_bd_topics_subscribe-&gt;topic, event-&gt;data_len)) {

        //         if (ptr_bd_topics_subscribe-&gt;hanler_provide) {
        //             ptr_bd_topics_subscribe-&gt;hanler_provide(event-&gt;data, event-&gt;data_len);
        //         }
        //     }
        //     idx_topic++;
        // }
        break;
    }

    case MQTT_EVENT_ERROR:
        ESP_LOGI(TAG, &quot;MQTT_EVENT_ERROR&quot;);
        // if (event-&gt;error_handle-&gt;error_type == MQTT_ERROR_TYPE_TCP_TRANSPORT) {
        //     log_error_if_nonzero(&quot;reported from esp-tls&quot;, event-&gt;error_handle-&gt;esp_tls_last_esp_err);
        //     log_error_if_nonzero(&quot;reported from tls stack&quot;, event-&gt;error_handle-&gt;esp_tls_stack_err);
        //     log_error_if_nonzero(&quot;captured as transport's socket errno&quot;,  event-&gt;error_handle-&gt;esp_transport_sock_errno);
        //     ESP_LOGI(TAG, &quot;Last errno string (%s)&quot;, strerror(event-&gt;error_handle-&gt;esp_transport_sock_errno));
        //     mqtt_reconnect();
        // }
        break;
    case MQTT_EVENT_BEFORE_CONNECT: {

    }
    break;
    default:
        ESP_LOGI(TAG, &quot;Other event id:%d&quot;, event-&gt;event_id);
        break;
    }
}

esp_err_t mqtt_start(void) {
    return esp_mqtt_client_start(client);
}

esp_err_t mqtt_stop(void) {
    return esp_mqtt_client_stop(client);
}

esp_err_t mqtt_reconnect(void) {
    return esp_mqtt_client_reconnect(client);
}

esp_err_t mqtt_disconnect(void) {
    return esp_mqtt_client_disconnect(client);
}

int mqtt_publish(const char *topic, const char *data, int len, int qos, int retain) {
    if (esp_mqtt_client_publish(client, topic, data, len, qos, retain) &gt; 0) {
        return ESP_OK;
    }
    return ESP_FAIL;
}

esp_err_t mqtt_app_init(topic_subscribe_set_t* bd_topics_subscribe) {
    ptr_bd_topics_subscribe = bd_topics_subscribe;
    client = esp_mqtt_client_init(&amp;mqtt_cfg);
    return esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, NULL);
}</text>
  </file>
  <file name="bip_cloud.h">
   <text>#ifndef QHSM_MQTT_H_
#define QHSM_MQTT_H_


#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &lt;string.h&gt;
#include &quot;esp_wifi.h&quot;
#include &quot;esp_system.h&quot;
#include &quot;esp_event.h&quot;
#include &quot;esp_netif.h&quot;

#include &quot;freertos/FreeRTOS.h&quot;
#include &quot;freertos/task.h&quot;
#include &quot;freertos/semphr.h&quot;
#include &quot;freertos/queue.h&quot;

#include &quot;lwip/sockets.h&quot;
#include &quot;lwip/dns.h&quot;
#include &quot;lwip/netdb.h&quot;

#include &quot;mqtt_client.h&quot;

#include &quot;esp_log.h&quot;

#include &quot;mqtt_settings.h&quot;
#include &quot;bsp.h&quot;
#include &quot;wifi_button.h&quot;

typedef void (*func_cb_t)(void *data, uint32_t len_data);


typedef struct topic_subscribe_set {
    const char*     topic;
    int             qos;
    func_cb_t       hanler_provide;
} topic_subscribe_set_t;

topic_subscribe_set_t list_topics_subscribe[];

esp_err_t mqtt_start(void);
esp_err_t mqtt_stop(void);
esp_err_t mqtt_reconnect(void);
esp_err_t mqtt_disconnect(void);

esp_err_t mqtt_app_init(topic_subscribe_set_t* bd_topics_subscribe);
esp_err_t mqtt_app_connect(void);
esp_err_t mqtt_app_disconnect(void);
bool check_mqtt_is_connect(void);

int mqtt_publish(const char *topic, const char *data, int len, int qos, int retain);

#endif // QHSM_MQTT_H_
</text>
  </file>
 </directory>
</model>
